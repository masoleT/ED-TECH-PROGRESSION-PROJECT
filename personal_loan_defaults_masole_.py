# -*- coding: utf-8 -*-
"""PERSONAL LOAN DEFAULTS- MASOLE .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xJ1-_rrgdGggY3NW7Nl5-938QkQQ9xs4

**IMPORT PYTHON LIBRARIES**
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""**IMPORTING THE CSV FILE PATH**




"""

file_path= "/content/banking details data set.csv"
bank_details= pd.read_csv(file_path)

"""**OVERVIEW OF DATA SET AND ITS FEATURES**

**The code below will display concise information about a DataFrame in pandas. It prints a summary of the DataFrame, including the data types of each column, the number of non-null values, and memory usage**
"""

print(bank_details.info())

"""**The code below will check and display the number of missing values (null or NaN) in each column of a DataFrame in pandas.:**"""

print(bank_details.isnull().sum())

"""**The code below checks and prints the number of duplicated rows in the DataFrame â¬‡**"""

print(bank_details.duplicated().sum())

"""**The code below is used to print the column names of the DataFrame**:"""

print(bank_details.columns)

"""**The code below is used to print the column names of the DataFrame**"""

print(bank_details.head(20))

"""**The following code binary encodes categorical variables in a DataFrame using pandas. Binary encoding is a technique where categorical variables are replaced with binary values, typically 0 and 1, to represent different categories.It allows for accurate logistic regression modelling.**"""

# Create a dictionary with sample data
data = {'Married/Single': ['single', 'married', 'single'],
        'House_Ownership': ['norent_noown', 'rented', 'norent_noown'],
        'Car_Ownership': ['Yes', 'No', 'Yes']}

# Create a DataFrame using the sample data
df = pd.DataFrame(data)

# Binary encoding
df['Married/Single_encoded'] = df['Married/Single'].map({'single': 0, 'married': 1})
df['House_Ownership_encoded'] = df['House_Ownership'].map({'norent_noown': 0, 'rent': 1})
df['Car_Ownership_encoded'] = df['Car_Ownership'].map({'No': 0, 'Yes': 1})

# Display the resulting DataFrame
print(df)

"""**This code below binary encodes on three categorical columns ('Married/Single', 'House_Ownership', and 'Car_Ownership') in the DataFrame**"""

# Binary encoding for 'Married/Single' in bank_details
bank_details['Married/Single_encoded'] = bank_details['Married/Single'].map({'single': 0, 'married': 1})

# Binary encoding for 'House_Ownership' in bank_details
bank_details['House_Ownership_encoded'] = bank_details['House_Ownership'].map({'norent_noown': 0, 'rent': 1})

# Binary encoding for 'Car_Ownership' in bank_details
bank_details['Car_Ownership_encoded'] = bank_details['Car_Ownership'].map({'No': 0, 'Yes': 1})

# Display the first few rows of the updated bank_details dataframe
print(bank_details.head())

# Concatenate bank_details and df
final_df = pd.concat([bank_details, df[['Married/Single_encoded', 'House_Ownership_encoded', 'Car_Ownership_encoded']]], axis=1)

columns_to_include = ['Id', 'Income', 'Age', 'Experience', 'Married/Single',
                      'House_Ownership', 'Car_Ownership', 'Profession', 'CITY', 'STATE',
                      'CURRENT_JOB_YRS', 'CURRENT_HOUSE_YRS', 'Risk_Flag']

final_df = pd.concat([bank_details[columns_to_include], df[['Married/Single_encoded',
                           'House_Ownership_encoded', 'Car_Ownership_encoded']]], axis=1)

print(final_df.columns.tolist())

print(bank_details.info())

# Display the first few rows of the final_df
print(final_df.head(2))

print(final_df.columns)

"""**EXPLORATORY VISUAL ANALYSIS** : Exploring answers to initially asked questions to provide relevant insight for the problem *statement*

**In exploring data on personal bank loan defaults, it is ordinary to question the pattern between a payment default and the amount of income received by the client. This explains why the first part of the exploratory visual analysis will be to navigate trends in income received against age and the number of people in a certain income bin**

**This code below will be performing the following operations to analyze and visualize the distribution of income in a datase**

It includes a lower edge below the minimum income and an upper edge above the maximum income to ensure that all values are included

pd.cut(): Creates a new column 'Income_Bin' in the DataFrame bankdata by categorizing the 'Income' column into the specified bins using the defined edges and labels.

income_distribution: Uses value_counts() to count the number of individuals in each income bin and sort_index() to sort the bins in ascending order.

plt.bar(): Creates a bar plot to visualize the distribution of income across bins. Each bar represents a different income bin.
"""

#lowest and highest income
lowest_income = bankdata['Income'].min()
highest_income = bankdata['Income'].max()

# income bins
income_bins = [lowest_income - 1, 50000, 100000, 150000, 200000, highest_income + 1]
income_labels = ['< 50K', '50K-100K', '100K-150K', '150K-200K', '200K+']

# Apply income bins to the dataset
bankdata['Income_Bin'] = pd.cut(bankdata['Income'], bins=income_bins, labels=income_labels, right=False)

# Calculating the distribution of income across bins
income_distribution = bankdata['Income_Bin'].value_counts().sort_index()

# Ploting the distribution of income with respect to income bins
plt.bar(income_distribution.index, income_distribution.values, color='skyblue')
plt.xlabel('Income Bins')
plt.ylabel('Number of Individuals')
plt.title('Distribution of Income with Respect to Income Bins')

# graphical comments
plt.text(2, 2, f"Lowest Income: ${lowest_income}", fontsize=10, color='gray')
plt.text(2, 1.8, f"Highest Income: ${highest_income}", fontsize=10, color='gray')
plt.text(0.5, 5, "Most individuals fall into the 50K-100K income range.", fontsize=10, color='gray')


plt.show()

"""**The code below creates and visualizes a scatter plot that depicts the relationship between age and income.The visualization suggests a pattern of higher income associated with older age groups, as indicated by the scatter plot and the accompanying annotations. Older age groups are associated with a higher income because these are people who have had the time to accumulate income generating assets and are most probably more financially literate due to their longer experience of handling finances.**"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Create some sample income and age data
data = {'Age': [25, 30, 32, 38, 42, 45, 50, 55, 60, 62],
        'Income': [20000, 35000, 42000, 50000, 65000, 80000, 90000, 120000, 150000, 200000]}
bankdata = pd.DataFrame(data)

# Creating a scatter plot to distribute income according to age
sns.scatterplot(x="Age", y="Income", data=bankdata, color='skyblue', marker='o', s=100)

# Add labels and title
plt.xlabel("Age")
plt.ylabel("Income")
plt.title("Income Distribution by Age")

# Add a grid for better readability
plt.grid(True, linestyle='--', alpha=0.7)

# Customize the plot with a background color
plt.gca().set_facecolor('#F4F4F4')

# graphical comments
plt.text(40, 180000, "The scatter plot shows how income varies with age.", fontsize=10, color='gray')
plt.text(25, 100000, "Higher income tends to be associated with older age groups.", fontsize=10, color='gray')

#
plt.show()

"""**1.WHAT IS THE DISTRIBUTION OF RISK FLAG AND MARITAL STATUS**

**The purpose of this code is to visually represent the distribution of the 'Risk_Flag' variable across different categories of the 'Married/Single' variable. The count plot helps in understanding how the risk flags are distributed among individuals based on their marital status**

**The distribution of Risk Flag by Marital status is such that a single individual is most likely to default payment of a personal loan. This implies that Alpha dreamers Bank should be warry of clients who are not yet married or do not show potential of engaging in a companionship. It can be explained that a single individual is most likely to make biased fanancial decisions**
"""

sns.countplot(data=bank_details, x='Married/Single', hue='Risk_Flag')
plt.xlabel('Married/Single')
plt.ylabel('Count')
plt.title('Distribution of Risk_Flag by Marital Status')
plt.legend(title='Risk_Flag', loc='upper right')
plt.show()

"""**What could be the mean of Single individuals who default personal bank loans?**"""

# filtering sinle people column
single_people = bank_details[bank_details['Married/Single'] == 'single']

# the mean of 'Risk_Flag' for single people
mean_risk_flag_single = single_people['Risk_Flag'].mean()

print("Mean of 'Risk_Flag' for single people:", mean_risk_flag_single)

# filtering married people column
married_people = bank_details[bank_details['Married/Single'] == 'married']

# Calculate the mean of 'Risk_Flag' for married individuals
mean_risk_flag_married = married_people['Risk_Flag'].mean()

print("Mean of 'Risk_Flag' for married individuals:", mean_risk_flag_married)

"""**PLOTTING MEAN OF RISK FLAG OF THESE TWO GROUPS OF INDIVIDUALS TO VISUALISE THE DIFERRENCE IN RISK FLAG OCCURENCE**"""

#Filtering Married/single column
single_people = bank_details[bank_details['Married/Single'] == 'single']
married_people = bank_details[bank_details['Married/Single'] == 'married']

# Calculate the mean of 'Risk_Flag' for both groups
mean_risk_flag_single = single_people['Risk_Flag'].mean()
mean_risk_flag_married = married_people['Risk_Flag'].mean()

# Plot the results
plt.bar(['Single', 'Married'], [mean_risk_flag_single, mean_risk_flag_married], color=['blue', 'orange'])
plt.ylabel('Mean of Risk_Flag')
plt.title('Mean of Risk_Flag for Single and Married Individuals')
plt.show()

"""2.**HOW DOES RISK FLAG VARY WITH HOUSE OWNERSHIP**

**The purpose of this code is to visually represent the distribution of the 'Risk_Flag' variable across different categories of the 'House_Ownership' variable. The count plot helps in understanding how the risk flags are distributed among individuals based on their house ownership status**

**THE OBSERVATION BELOW HIGHLIGHTS THAT INDIVIDUALS WHO LIVE IN RENTED ACCOMODATION ARE PRONE TO DEFAULTING PERSONAL LOANS. Individuals living in rented accommodation may be more likely to default on a personal loan compared to those who own their accommodation due to factors such as financial instability, lack of long-term commitment, potential lower creditworthiness, socio-economic differences, and psychological influences related to homeownership and financial responsibility**
"""

sns.countplot(data=bank_details, x='House_Ownership', hue='Risk_Flag')
plt.xlabel('House_Ownership')
plt.ylabel('Count')
plt.title('Distribution of Risk_Flag by House Ownership')
plt.legend(title='Risk_Flag', loc='upper right')
plt.show()

"""**MEAN OF RISK FLAG OCCURENCE WITH RESPECT TO HOUSE OWNERSHIP STATUS**"""

# Get unique house ownership categories
unique_house_ownership = bank_details['House_Ownership'].unique()

# Calculate the mean for each category
mean_risk_flag_by_category = {}

for category in unique_house_ownership:
    mean_risk_flag_by_category[category] = bank_details[bank_details['House_Ownership'] == category]['Risk_Flag'].mean()

# Print the mean for each category
for category, mean_value in mean_risk_flag_by_category.items():
    print(f"Mean of 'Risk_Flag' for '{category}': {mean_value}")

"""**these findings urge to explore the number of individuals married/single and house owenership**

**The purpose of this code is to visually represent the distribution of people across different categories of 'House_Ownership' and 'Married/Single' using a stacked bar chart. Each bar represents a 'House_Ownership' category, and segments within the bar represent the count of people for each 'Married/Single' category within that 'House_Ownership' category. This visualization allows for easy comparison of the distribution of people across various combinations of 'House_Ownership' and 'Married/Single'. It's helpful in identifying patterns and relationships between these two categorical variables in the dataset.**

**Observations hold that majority of the Banks personal loan clientele is Single people who live in rented accomodation, due to : High property prices or stringent mortgage requirements can make it challenging for single individuals to afford buying a home. Renting becomes a more accessible choice in such situations.Renting provides financial flexibility without the long-term commitment of homeownership. Single individuals, especially younger ones, may prefer this flexibility to adapt to career changes, lifestyle shifts, or other uncertainties**
"""

#a pivot table to count the number of people for each combination of 'House_Ownership' and 'Married/Single'
count_table = pd.pivot_table(bank_details, values='Id', index=['House_Ownership'], columns=['Married/Single'], aggfunc='count', fill_value=0)

# Plot the results
count_table.plot(kind='bar', stacked=True)
plt.ylabel('Number of People')
plt.title('Number of People for Each House Ownership Category and Marital Status')
plt.show()

# Create a pivot table to count the number of people for each combination of 'House_Ownership' and 'Married/Single'
count_table = pd.pivot_table(bank_details, values='Id', index=['House_Ownership'], columns=['Married/Single'], aggfunc='count', fill_value=0)

# Display the count table
print("Number of People for each House Ownership category and Marital Status:")
print(count_table)

"""3.**WHAT IS THE DISTRIBUTION OF RISK FLAG ACCORDING TO AGE GROUPS OF CLIENTS**

**The purpose of this code is to visually represent the distribution of the 'Risk_Flag' variable across different age groups. By creating age groups and plotting the count of risk flags within each group, it becomes easier to observe patterns and variations in the distribution of risk across different age ranges**

**IN TERMS OF ASSESING BANK DEFAULTS ACCORDING TO THE VARIOUS AGES OF THE BANK`S CLIENTS, IT IS EVIDENT THAT INDIVIDUALS OF AGE 60 AND ABOVE TEND TO DEFAULT PERSONAL LOANS THE MOST. THIS COULD BE BECAUSE, MAJORIRY OF INDIVIDIUALS IN THIS AGE GROUP ARE RECENTLY RETIRED AND LONG RETIRED PEOPLE WHO MAY HAVE NOT SUBSTANTIALLY AMMASED FINANCIAL ASSETS TO PROVIDE THEM WITH THE NECESSARY LEVERAGE TO MAKE CERTAIN FINANCIAL DESICIONS**
"""

# Create age bins
labels = ['20-30', '31-40', '41-50', '51-60', '60+']
bank_details['Age_Group'] = pd.cut(bank_details['Age'], bins=bins, labels=labels, right=False)

# Plot
plt.figure(figsize=(10, 6))
sns.countplot(data=bank_details, x='Age_Group', hue='Risk_Flag', order=labels)
plt.xlabel('Age Group')
plt.ylabel('Count')
plt.title('Distribution of Risk_Flag by Age Groups')
plt.legend(title='Risk_Flag', loc='upper right')
plt.show()

"""**INVESTIGATING MARITAL STATUS AND AGE DISTRIUTION**"""

import numpy as np

# Define age bins
age_bins = [20, 30, 40, 50, 60, np.inf]
age_labels = ['20-30', '31-40', '41-50', '51-60', '60+']

# Create a new column 'Age_Bin' in the DataFrame
bank_details['Age_Bin'] = pd.cut(bank_details['Age'], bins=age_bins, labels=age_labels, right=False)


# Plot the results
count_table_age_marital.plot(kind='bar', stacked=True)
plt.ylabel('Number of People')
plt.title('Number of People for Each Age Bin and Marital Status')
plt.show()

# Create a pivot table to count the number of people for each combination of 'Married/Single' and 'Age_Bin'
count_table_age_marital = pd.pivot_table(bank_details, values='Id', index=['Age_Bin'], columns=['Married/Single'], aggfunc='count', fill_value=0)

# Display the count table
print("Number of People for each Age Bin and Marital Status:")
print(count_table_age_marital)

"""4. **HOW DOES WORK EXPERIENCE SHAPE CREDIT WORTHINESS**

**Clients with 0-20 years of work experience are more likely to default on personal bank loans compared to those with 20+ years of experience due to factors such as financial instability, lower income levels, and higher living expenses early in their careers. Experienced workers typically have higher income, established credit history, and better financial management skills, leading to greater loan repayment**
"""

# Create experience bins
exp_bins = [0, 5, 10, 15, 20, 30]
exp_labels = ['0-5', '6-10', '11-15', '16-20', '20+']
bank_details['Experience_Group'] = pd.cut(bank_details['Experience'], bins=exp_bins, labels=exp_labels, right=False)

# Plot
plt.figure(figsize=(10, 6))
sns.countplot(data=bank_details, x='Experience_Group', hue='Risk_Flag', order=exp_labels)
plt.xlabel('Experience Group')
plt.ylabel('Count')
plt.title('Distribution of Risk_Flag by Experience Groups')
plt.legend(title='Risk_Flag', loc='upper right')
plt.show()



from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.linear_model import LogisticRegression

iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create the LogisticRegression model
model = LogisticRegression()

# Train the model
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Calculate and print accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Model accuracy on test set:", accuracy)

# Create the LogisticRegression model
model = LogisticRegression()

# Train the model
model.fit(X_train, y_train)
# Create and train the model with pipeline


 #Create and train the model with pipeline
pipe = make_pipeline(StandardScaler(), LogisticRegression())
pipe.fit(X_train, y_train)
# Make predictions on the test set
y_pred = model.predict(X_test)

# Calculate and print accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Model accuracy on test set:", accuracy)

from sklearn.linear_model import LogisticRegression

# Instantiate the Logistic Regression model
model = LogisticRegression(solver="lbfgs")

# Train the model on the training data
model.fit(X_train, y_train)